/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.lexer.LexerTokens.COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_FUNCTION_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_START
import org.js.vento.plugin.lexer.LexerTokens.FOR_START
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_START
import org.js.vento.plugin.lexer.LexerTokens.JAVASCRIPT_START
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.SET_START
import org.js.vento.plugin.lexer.LexerTokens.TRIM_COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.VARIABLE_START

/**
/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses variable declarations using `{{ set ... }}` blocks
 * - Parses import statements with `{{ import ... from ... }}`
 * - Parses export blocks with `{{ export ... }}`
 * - Parses for loops with `{{ for ... of ... }}`
 * - Parses JavaScript expressions and piped transformations
 * - Handles comments with `{# ... #}` syntax
 *
 * The parser works incrementally, processing one token at a time to build up the AST.
 * It uses marker-based tree building to create proper nesting of elements.
 *
 * Each language construct has a dedicated parsing method:
 * - `parseSet()` for variable declarations and content blocks
 * - `parseImport()` for importing from other templates
 * - `parseExport()` for exporting variables and functions
 * - `parseFor()` for iteration constructs
 * - `parseElement()` for dispatching to specific element parsers
 *
 * The parser integrates with IntelliJ's PSI infrastructure for syntax highlighting,
 * code completion, and other language features.
 *
 * See also:
 * - `VentoParserDefinition` for IDE integration
 * - `VentoLexer` for token generation
 * - `VentoJavaScriptInjector` for JavaScript support
 */
 */
class Parser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    private fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType
        builder.setDebugMode(true)
        when (tokenType) {
            COMMENT_START, TRIM_COMMENT_START -> parseCommentBlock(builder)
            JAVASCRIPT_START -> parseJavaScript(builder)
            VARIABLE_START -> parseVariable(builder)
            FOR_START -> parseFor(builder)
            IMPORT_START -> parseImport(builder)
            EXPORT_START -> parseExport(builder)
            EXPORT_CLOSE_START -> parseExportClose(builder)
            EXPORT_FUNCTION_START -> parseExportFunction(builder)
            SET_START -> parsSet(builder)
            SET_CLOSE_START -> parsSetClose(builder)
            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.UNKNOWN_ELEMENT)
            }
        }
    }
}
