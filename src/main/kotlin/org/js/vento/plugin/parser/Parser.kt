/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.VentoLanguage
import org.js.vento.plugin.lexer.VentoLexerTypes
import org.js.vento.plugin.lexer.VentoLexerTypes.UNKNOWN

/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses the root structure of a Vento template file and constructs the AST.
 * - Delegates parsing of specific elements, such as JavaScript blocks, to dedicated methods.
 *
 * Workflow:
 * 1. The `parse` method processes the entire file content.
 * 2. The parsing is done incrementally, processing each token in the file.
 * 3. Elements like JavaScript blocks or generic template elements are handled by corresponding methods.
 *
 * Key methods:
 * - `parse`: The entry point for parsing, iterates through the token stream and processes each token.
 * - `parseElement`: Handles parsing of individual elements in the structure.
 * - `parseJavaScriptElement`: Responsible for parsing blocks of JavaScript code embedded in the template.
 *
 * See also:
 * - `PsiParser` for IntelliJ IDEA's parsing handler interfaces.
 * - `VentoParserDefinition` for how this parser integrates with the IDE.
 * - `VentoJavaScriptInjector` for handling JavaScript code injection in parsed elements.
 */
class VentoParser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    private fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType

        when (tokenType) {
            VentoLexerTypes.COMMENT_START, VentoLexerTypes.TRIM_COMMENT_START -> parseCommentBlock(builder)
            VentoLexerTypes.JAVASCRIPT_START -> parseJavaScript(builder)
            VentoLexerTypes.VARIABLE_START -> parseVariable(builder)
            VentoLexerTypes.FOR_START -> parseFor(builder)
            VentoLexerTypes.IMPORT_START -> parseImport(builder)
            VentoLexerTypes.EXPORT_START -> parseExport(builder)
            VentoLexerTypes.EXPORT_CLOSE_START -> parseExportClose(builder)
            VentoLexerTypes.EXPORT_FUNCTION_START -> parseExportFunction(builder)
            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserTypes.VENTO_ELEMENT)
            }
        }
    }

    private fun parseImport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, VentoLexerTypes.IMPORT_START, "Expected '{{' ")
        expect(builder, VentoLexerTypes.IMPORT_KEY, "Expected 'import' keyword")
        expect(builder, VentoLexerTypes.IMPORT_VALUES, "Expected import values", true)
        expect(builder, VentoLexerTypes.IMPORT_FROM, "Expected 'from' keyword")
        expect(builder, VentoLexerTypes.IMPORT_FILE, "Expected vento(.vto) path string")
        expect(builder, VentoLexerTypes.IMPORT_END, "Expected '}}' ")

        m.done(ParserTypes.IMPORT_ELEMENT)
    }

    private fun parseExport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, VentoLexerTypes.EXPORT_START, "Expected '{{' ")
        expect(builder, VentoLexerTypes.EXPORT_KEY, "Expected 'export' keyword")
        expect(builder, VentoLexerTypes.EXPORT_VAR, "Expected variable", true)
        val hasEq = optional(builder, VentoLexerTypes.EXPORT_EQ, "Expected '=' keyword")
        val hasVal =
            if (builder.tokenType == VentoLexerTypes.EXPORT_VALUE) {
                optional(builder, VentoLexerTypes.EXPORT_VALUE, "Expected value")
            } else {
                optional(builder, VentoLexerTypes.STRING, "Expected value", true)
            }
        if (builder.tokenType == VentoLexerTypes.PIPE_ELEMENT) {
            expect(builder, VentoLexerTypes.PIPE_ELEMENT, "Expected pipe (|>)")
            expect(builder, VentoLexerTypes.VARIABLE_ELEMENT, "Expected pipe (|>)", true)
        }
        expect(builder, VentoLexerTypes.EXPORT_END, "Expected '}}' ")

        if ((hasEq && !hasVal) || (!hasEq && hasVal)) {
            builder.error("Expected value after '='")
        }

        if (hasEq && hasVal) {
            m.done(ParserTypes.EXPORT_ELEMENT)
        } else {
            m.done(ParserTypes.EXPORT_OPEN_ELEMENT)
        }
    }

    private fun parseExportClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, VentoLexerTypes.EXPORT_CLOSE_START, "Expected '{{/' ")
        expect(builder, VentoLexerTypes.EXPORT_CLOSE_KEY, "Expected '/export' keyword")
        expect(builder, VentoLexerTypes.EXPORT_CLOSE_END, "Expected '}}' ")

        m.done(ParserTypes.EXPORT_CLOSE_ELEMENT)
    }

    private fun parseExportFunction(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, VentoLexerTypes.EXPORT_FUNCTION_START, "Expected '{{' ")
        expect(builder, VentoLexerTypes.EXPORT_KEY, "Expected 'export' keyword")
        expect(builder, VentoLexerTypes.EXPORT_FUNCTION_KEY, "Expected 'function' keyword")
        expect(builder, VentoLexerTypes.EXPORT_VAR, "Expected function name")
        expect(builder, VentoLexerTypes.EXPORT_FUNCTION_ARGS, "Expected function arguments: (arg1[,arg2])", true)
        expect(builder, VentoLexerTypes.EXPORT_FUNCTION_END, "Expected '}}' ")

        m.done(ParserTypes.EXPORT_FUNCTION_ELEMENT)
    }

    private fun parseFor(builder: PsiBuilder) {
        val m = builder.mark()
        builder.advanceLexer() // consume {{

        // Consume content tokens until we see the end or EOF
        while (
            !builder.eof() &&
            (
                builder.tokenType == VentoLexerTypes.CLOSE_FOR_KEY ||
                    builder.tokenType == VentoLexerTypes.FOR_KEY ||
                    builder.tokenType == VentoLexerTypes.FOR_VALUE ||
                    builder.tokenType == VentoLexerTypes.FOR_OF ||
                    builder.tokenType == VentoLexerTypes.FOR_COLLECTION ||
                    builder.tokenType == VentoLexerTypes.ERROR
            )
        ) {
            builder.advanceLexer()
        }

        if (builder.tokenType == VentoLexerTypes.FOR_END) {
            builder.advanceLexer()
        }

        m.done(ParserTypes.VENTO_FOR_ELEMENT)
    }

    private fun parseVariable(builder: PsiBuilder) {
        val m = builder.mark()
        builder.advanceLexer() // consume {{ or {{-

        // Consume content tokens until we see the end or EOF
        while (
            !builder.eof() &&
            (
                builder.tokenType == VentoLexerTypes.VARIABLE_ELEMENT ||
                    builder.tokenType == VentoLexerTypes.PIPE_ELEMENT ||
                    builder.tokenType == VentoLexerTypes.STRING
            )
        ) {
            builder.advanceLexer()
        }

        // Expect end
        if (builder.tokenType == VentoLexerTypes.VARIABLE_END) {
            builder.advanceLexer()
        } else {
            builder.error("Expected '}}' to close variable")
        }

        m.done(ParserTypes.JAVACRIPT_VARIABLE_ELEMENT)
    }

    private fun parseJavaScript(builder: PsiBuilder) {
        val marker = builder.mark()

        if (builder.tokenType == VentoLexerTypes.JAVASCRIPT_START) {
            builder.advanceLexer()
        }

        if (builder.tokenType == ParserTypes.JAVASCRIPT_ELEMENT) {
            builder.advanceLexer()
        }

        if (builder.tokenType == VentoLexerTypes.JAVASCRIPT_END) {
            builder.advanceLexer()
        }

        marker.done(ParserTypes.JAVASCRIPT_ELEMENT)
    }

    private fun parseCommentBlock(builder: PsiBuilder) {
        val marker = builder.mark()

        // Consume opening token
        builder.advanceLexer()

        // Consume content tokens
        while (!builder.eof() &&
            builder.tokenType == VentoLexerTypes.COMMENT_CONTENT
        ) {
            builder.advanceLexer()
        }

        // Consume closing token if present
        if (builder.tokenType == VentoLexerTypes.COMMENT_END ||
            builder.tokenType == VentoLexerTypes.TRIM_COMMENT_END
        ) {
            builder.advanceLexer()
        }

        marker.done(ParserTypes.COMMENT_BLOCK)
    }
}

/**
 * Represents an element type for the Vento language.
 * Typically used for syntax/AST nodes in the PSI tree.
 */
class VentoParserElementType(debugName: String) : IElementType(debugName, VentoLanguage)

private fun expect(builder: PsiBuilder, expected: IElementType, message: String, expectMultipleTokens: Boolean = false): Boolean {
    return if (builder.tokenType == expected) {
        builder.advanceLexer()
        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
        }
        builder.error(message)
        false
    }
}

private fun optional(builder: PsiBuilder, expected: IElementType, message: String, expectMultipleTokens: Boolean = false): Boolean {
    return if (builder.tokenType == expected) {
        builder.advanceLexer()
        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
            builder.error(message)
            return false
        }
        false
    }
}
