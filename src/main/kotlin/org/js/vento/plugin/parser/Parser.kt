/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.VentoLanguage
import org.js.vento.plugin.lexer.LexerTokens
import org.js.vento.plugin.lexer.LexerTokens.BRACKET
import org.js.vento.plugin.lexer.LexerTokens.COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.DOT
import org.js.vento.plugin.lexer.LexerTokens.EQUAL
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_FUNCTION_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_START
import org.js.vento.plugin.lexer.LexerTokens.EXPRESSION
import org.js.vento.plugin.lexer.LexerTokens.FILE
import org.js.vento.plugin.lexer.LexerTokens.FOR_START
import org.js.vento.plugin.lexer.LexerTokens.IDENTIFIER
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_START
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_END
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_KEY
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_START
import org.js.vento.plugin.lexer.LexerTokens.JAVASCRIPT_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_START
import org.js.vento.plugin.lexer.LexerTokens.OBJECT
import org.js.vento.plugin.lexer.LexerTokens.PIPE
import org.js.vento.plugin.lexer.LexerTokens.REGEX
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_END
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.SET_END
import org.js.vento.plugin.lexer.LexerTokens.SET_KEY
import org.js.vento.plugin.lexer.LexerTokens.SET_START
import org.js.vento.plugin.lexer.LexerTokens.STRING
import org.js.vento.plugin.lexer.LexerTokens.TRIM_COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.UNKNOWN
import org.js.vento.plugin.lexer.LexerTokens.VARIABLE_START
import org.js.vento.plugin.parser.ParserElements.LAYOUT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.OBJECT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_ELEMENT

/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses the root structure of a Vento template file and constructs the AST.
 * - Delegates parsing of specific elements, such as JavaScript blocks, to dedicated methods.
 *
 * Workflow:
 * 1. The `parse` method processes the entire file content.
 * 2. The parsing is done incrementally, processing each token in the file.
 * 3. Elements like JavaScript blocks or generic template elements are handled by corresponding methods.
 *
 * Key methods:
 * - `parse`: The entry point for parsing, iterates through the token stream and processes each token.
 * - `parseElement`: Handles parsing of individual elements in the structure.
 * - `parseJavaScriptElement`: Responsible for parsing blocks of JavaScript code embedded in the template.
 *
 * See also:
 * - `PsiParser` for IntelliJ IDEA's parsing handler interfaces.
 * - `VentoParserDefinition` for how this parser integrates with the IDE.
 * - `VentoJavaScriptInjector` for handling JavaScript code injection in parsed elements.
 */
class VentoParser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType
        builder.setDebugMode(true)
        when (tokenType) {
            COMMENT_START, TRIM_COMMENT_START -> parseCommentBlock(builder)
            JAVASCRIPT_START -> parseJavaScript(builder)
            VARIABLE_START -> parseVariable(builder)
            FOR_START -> parseFor(builder)
            IMPORT_START -> parseImport(builder)
            EXPORT_START -> parseExport(builder)
            EXPORT_CLOSE_START -> parseExportClose(builder)
            EXPORT_FUNCTION_START -> parseExportFunction(builder)
            LAYOUT_START -> parseLayout(builder)
            LAYOUT_CLOSE_START -> parseLayoutClose(builder)
            SET_START -> parsSet(builder)
            SET_CLOSE_START -> parsSetClose(builder)
//            STRING, REGEX, BRACKET, DOT, IDENTIFIER, EXPRESSION, UNKNOWN -> parseExpression(builder)
            LAYOUT_SLOT_START -> parseSlot(builder)
            LAYOUT_SLOT_CLOSE_START -> parseSlotClose(builder)
            OBJECT -> parseObject(builder)
            INCLUDE_START -> parseInclude(builder)
            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.DEFAULT_ELEMENT)
            }
        }
    }

    private fun parseInclude(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, INCLUDE_START, "Expected '{{' ")
        expect(builder, INCLUDE_KEY, "Expected 'include' keyword' ")
        parseExpression(builder)
        parseObject(builder)
        parsePipe(builder)
        expect(builder, INCLUDE_END, "Expected '}}'")
        m.done(ParserElements.INCLUDE_ELEMENT)
    }

    private fun parseObject(builder: PsiBuilder) {
        val m = builder.mark()
        while (
            !builder.eof() &&
            (
                builder.tokenType == OBJECT ||
                    builder.tokenType == STRING
            )
        ) {
            builder.advanceLexer()
        }
        m.done(OBJECT_ELEMENT)
    }

    private fun parseSlotClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_CLOSE_START, "Expected '{{' ")
        expect(builder, LAYOUT_SLOT_CLOSE_KEY, "Expected slot keyword")
        expect(builder, LAYOUT_SLOT_CLOSE_END, "Expected '}}'")
        m.done(LAYOUT_SLOT_CLOSE_ELEMENT)
    }

    private fun parseSlot(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_START, "Expected '{{' ")
        expect(builder, LAYOUT_SLOT_KEY, "Expected slot keyword")
        expect(builder, IDENTIFIER, "Expected identifier")
        parsePipe(builder)
        expect(builder, LAYOUT_SLOT_END, "Expected '}}'")
        m.done(LAYOUT_SLOT_ELEMENT)
    }

    private fun parseLayout(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_START, "Expected '{{' ")
        expect(builder, LAYOUT_KEY, "Expected layout keyword")
        expect(builder, FILE, "Expected filepath")
        parsePipe(builder)
        if (builder.tokenType == OBJECT) {
            parseObject(builder)
        }
        expect(builder, LAYOUT_END, "Expected '}}'")
        m.done(LAYOUT_ELEMENT)
    }

    private fun parseLayoutClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_CLOSE_START, "Expected '{{' ")
        expect(builder, LAYOUT_CLOSE_KEY, "Expected /layout keyword")
        expect(builder, LAYOUT_CLOSE_END, "Expected '}}'")
        m.done(LAYOUT_CLOSE_ELEMENT)
    }

    private fun parsSetClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, SET_CLOSE_START, "Expected '{{' ")
        expect(builder, SET_CLOSE_KEY, "Expected '/set' keyword")
        expect(builder, SET_CLOSE_END, "Expected '}}' ")
        m.done(SET_CLOSE_ELEMENT)
    }

    private fun parsSet(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, SET_START, "Expected '{{' ")
        expect(builder, SET_KEY, "Expected 'set' keyword")
        expect(builder, IDENTIFIER, "Expected identifier")

        val hasEq = optional(builder, EQUAL, "Expected '=' keyword")

        val hasExp: Boolean = parseExpression(builder, hasEq)

        if (hasEq && !hasExp) builder.error("Expected expression after '='")
        if (!hasEq && hasExp) builder.error("Expected '='")

        parsePipe(builder)

        expect(builder, SET_END, "Expected '}}' ")

        m.done(SET_ELEMENT)
    }

    private fun parsePipe(builder: PsiBuilder) {
        if (builder.tokenType == PIPE) {
            expect(builder, PIPE, "Expected pipe (|>)")
            parseExpression(builder)
        }
    }

    private fun parseImport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, IMPORT_START, "Expected '{{' ")
        expect(builder, LexerTokens.IMPORT_KEY, "Expected 'import' keyword")
        expect(builder, LexerTokens.IMPORT_VALUES, "Expected import values", true)
        expect(builder, LexerTokens.IMPORT_FROM, "Expected 'from' keyword")
        expect(builder, LexerTokens.IMPORT_FILE, "Expected vento(.vto) path string")
        expect(builder, LexerTokens.IMPORT_END, "Expected '}}' ")

        m.done(ParserElements.IMPORT_ELEMENT)
    }

    private fun parseExport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_START, "Expected '{{' ")
        expect(builder, LexerTokens.EXPORT_KEY, "Expected 'export' keyword")
        expect(builder, LexerTokens.EXPORT_VAR, "Expected variable", true)

        val hasEq = optional(builder, EQUAL, "Expected '=' keyword")
        var hasVal = false
        if (hasEq) hasVal = parseExpression(builder)
        if (hasEq && !hasVal) builder.error("Expected expression after '='")

        while (!builder.eof() && builder.tokenType == PIPE) {
            val hasPipe = optional(builder, PIPE, "Expected pipe (|>)")
            var hasPipeExpression = false
            if (hasPipe) hasPipeExpression = parseExpression(builder)
            if (hasPipe && !hasPipeExpression) builder.error("Expected expression after '|>'")
        }

        expect(builder, LexerTokens.EXPORT_END, "Expected '}}' ")

        if (hasEq) {
            m.done(ParserElements.EXPORT_ELEMENT)
        } else {
            m.done(ParserElements.EXPORT_OPEN_ELEMENT)
        }
    }

    private fun parseExpression(builder: PsiBuilder, required: Boolean = true): Boolean {
        val m = builder.mark()

        var hasExpression = false
        while (
            !builder.eof() &&
            (
                builder.tokenType == EXPRESSION ||
                    builder.tokenType == STRING ||
                    builder.tokenType == REGEX ||
                    builder.tokenType == BRACKET ||
                    builder.tokenType == DOT ||
                    builder.tokenType == IDENTIFIER ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            if (builder.tokenType == UNKNOWN) {
                if (required) builder.error("Unexpected expression content")
            } else if (builder.tokenType == IDENTIFIER ||
                builder.tokenType == EXPRESSION ||
                builder.tokenType == STRING ||
                builder.tokenType == REGEX
            ) {
                hasExpression = true
            }
            builder.advanceLexer()
        }
        if (!hasExpression && required) builder.error("Expected expression")
        if (hasExpression) m.done(ParserElements.EXPRESSION) else m.drop()

        return hasExpression
    }

    private fun parseExportClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_CLOSE_START, "Expected '{{/' ")
        expect(builder, LexerTokens.EXPORT_CLOSE_KEY, "Expected '/export' keyword")
        expect(builder, LexerTokens.EXPORT_CLOSE_END, "Expected '}}' ")

        m.done(ParserElements.EXPORT_CLOSE_ELEMENT)
    }

    private fun parseExportFunction(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_FUNCTION_START, "Expected '{{' ")
        expect(builder, LexerTokens.EXPORT_KEY, "Expected 'export' keyword")
        expect(builder, LexerTokens.EXPORT_FUNCTION_KEY, "Expected 'function' keyword")
        expect(builder, LexerTokens.EXPORT_VAR, "Expected function name")
        expect(builder, LexerTokens.EXPORT_FUNCTION_ARGS, "Expected function arguments: (arg1[,arg2])", true)
        expect(builder, LexerTokens.EXPORT_FUNCTION_END, "Expected '}}' ")

        m.done(ParserElements.EXPORT_FUNCTION_ELEMENT)
    }

    private fun parseFor(builder: PsiBuilder) {
        val m = builder.mark()
        builder.advanceLexer() // consume {{

        // Consume content tokens until we see the end or EOF
        while (
            !builder.eof() &&
            (
                builder.tokenType == LexerTokens.FOR_CLOSE_KEY ||
                    builder.tokenType == LexerTokens.FOR_KEY ||
                    builder.tokenType == LexerTokens.FOR_VALUE ||
                    builder.tokenType == LexerTokens.FOR_OF ||
                    builder.tokenType == LexerTokens.FOR_COLLECTION ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            builder.advanceLexer()
        }

        if (builder.tokenType == LexerTokens.FOR_END) {
            builder.advanceLexer()
        }

        m.done(ParserElements.FOR_ELEMENT)
    }

    private fun parseVariable(builder: PsiBuilder) {
        val m = builder.mark()
        builder.advanceLexer() // consume {{ or {{-

        // Consume content tokens until we see the end or EOF
        while (
            !builder.eof() &&
            (
                builder.tokenType == LexerTokens.VARIABLE_ELEMENT ||
                    builder.tokenType == PIPE ||
                    builder.tokenType == STRING ||

                    builder.tokenType == UNKNOWN
            )
        ) {
            if (builder.tokenType == UNKNOWN) {
                builder.error("Unexpected variable content")
            }
            builder.advanceLexer()
        }

        // Expect end
        if (builder.tokenType == LexerTokens.VARIABLE_END) {
            builder.advanceLexer()
        } else {
            builder.error("Unexpected variable content")
        }

        m.done(ParserElements.JAVACRIPT_VARIABLE_ELEMENT)
    }

    private fun parseJavaScript(builder: PsiBuilder) {
        val marker = builder.mark()

        if (builder.tokenType == JAVASCRIPT_START) {
            builder.advanceLexer()
        }

        if (builder.tokenType == ParserElements.JAVASCRIPT_ELEMENT) {
            builder.advanceLexer()
        }

        if (builder.tokenType == LexerTokens.JAVASCRIPT_END) {
            builder.advanceLexer()
        }

        marker.done(ParserElements.JAVASCRIPT_ELEMENT)
    }

    private fun parseCommentBlock(builder: PsiBuilder) {
        val marker = builder.mark()

        // Consume opening token
        builder.advanceLexer()

        // Consume content tokens
        while (!builder.eof() &&
            builder.tokenType == LexerTokens.COMMENT_CONTENT
        ) {
            builder.advanceLexer()
        }

        // Consume closing token if present
        if (builder.tokenType == LexerTokens.COMMENT_END ||
            builder.tokenType == LexerTokens.TRIM_COMMENT_END
        ) {
            builder.advanceLexer()
        }

        marker.done(ParserElements.COMMENT_BLOCK)
    }
}

/**
 * Represents an element type for the Vento language.
 * Typically used for syntax/AST nodes in the PSI tree.
 */
class ParserElement(debugName: String) : IElementType(debugName, VentoLanguage)

private fun expect(builder: PsiBuilder, expected: IElementType, message: String, expectMultipleTokens: Boolean = false): Boolean {
    return if (builder.tokenType == expected) {
        builder.advanceLexer()
        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
        }
        builder.error(message)
        false
    }
}

private fun optional(builder: PsiBuilder, expected: IElementType, message: String, expectMultipleTokens: Boolean = false): Boolean {
    return if (builder.tokenType == expected) {
        builder.advanceLexer()
        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
            builder.error(message)
            return false
        }
        false
    }
}
