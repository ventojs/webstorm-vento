/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.lexer.LexerTokens
import org.js.vento.plugin.lexer.LexerTokens.BOOLEAN
import org.js.vento.plugin.lexer.LexerTokens.BRACE
import org.js.vento.plugin.lexer.LexerTokens.BRACKET
import org.js.vento.plugin.lexer.LexerTokens.COLON
import org.js.vento.plugin.lexer.LexerTokens.COMMA
import org.js.vento.plugin.lexer.LexerTokens.COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.DOT
import org.js.vento.plugin.lexer.LexerTokens.ECHO_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.ECHO_KEY
import org.js.vento.plugin.lexer.LexerTokens.EQUAL
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.FILE
import org.js.vento.plugin.lexer.LexerTokens.FOR_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_OF
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_ARGS
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_KEY
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_FROM
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_VALUES
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_KEY
import org.js.vento.plugin.lexer.LexerTokens.INSTANCEOF
import org.js.vento.plugin.lexer.LexerTokens.JAVASCRIPT
import org.js.vento.plugin.lexer.LexerTokens.JSBLOCK_CLOSE
import org.js.vento.plugin.lexer.LexerTokens.JSBLOCK_OPEN
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_KEY
import org.js.vento.plugin.lexer.LexerTokens.MINUS
import org.js.vento.plugin.lexer.LexerTokens.NEW
import org.js.vento.plugin.lexer.LexerTokens.NUMBER
import org.js.vento.plugin.lexer.LexerTokens.PARENTHESIS
import org.js.vento.plugin.lexer.LexerTokens.PIPE
import org.js.vento.plugin.lexer.LexerTokens.PLUS
import org.js.vento.plugin.lexer.LexerTokens.REGEX
import org.js.vento.plugin.lexer.LexerTokens.SEMICOLON
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.SET_KEY
import org.js.vento.plugin.lexer.LexerTokens.STATEMENT
import org.js.vento.plugin.lexer.LexerTokens.STRING
import org.js.vento.plugin.lexer.LexerTokens.SYMBOL
import org.js.vento.plugin.lexer.LexerTokens.UNKNOWN
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_CLOSE
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_OPEN
import org.js.vento.plugin.parser.ParserElements.JAVASCRIPT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_ELEMENT
import org.js.vento.plugin.parser.ParserElements.VENTO_ELEMENT

/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses the root structure of a Vento template file and constructs the AST.
 * - Delegates parsing of specific elements, such as JavaScript blocks, to dedicated methods.
 *
 * Workflow:
 * 1. The `parse` method processes the entire file content.
 * 2. The parsing is done incrementally, processing each token in the file.
 * 3. Elements like JavaScript blocks or generic template elements are handled by corresponding methods.
 *
 * Key methods:
 * - `parse`: The entry point for parsing, iterates through the token stream and processes each token.
 * - `parseElement`: Handles parsing of individual elements in the structure.
 * - `parseJavaScriptElement`: Responsible for parsing blocks of JavaScript code embedded in the template.
 *
 * See also:
 * - `PsiParser` for IntelliJ IDEA's parsing handler interfaces.
 * - `VentoParserDefinition` for how this parser integrates with the IDE.
 * - `VentoJavaScriptInjector` for handling JavaScript code injection in parsed elements.
 */
class Parser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType
        builder.setDebugMode(true)

        when (tokenType) {
            COMMENT_START -> parseCommentBlock(builder)
            JSBLOCK_OPEN -> parseJavaScript(builder)
            VBLOCK_OPEN -> {
                val m = builder.mark()
                expect(builder, VBLOCK_OPEN, "Expected '{{' ")
                parseVentoElemenet(builder)
                expect(builder, VBLOCK_CLOSE, "Expected '}}' ")
                m.done(VENTO_ELEMENT)
            }

            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.DEFAULT_ELEMENT)
            }
        }
    }

    private fun parseVentoElemenet(builder: PsiBuilder) {
        when (builder.tokenType) {
            ECHO_KEY -> parseEcho(builder)
            ECHO_CLOSE_KEY -> parseEchoClose(builder)
            EXPORT_CLOSE_KEY -> parseExportClose(builder)
            EXPORT_KEY -> parseExport(builder)
            FOR_CLOSE_KEY -> parseForClose(builder)
            FOR_KEY -> parseFor(builder)
            IMPORT_KEY -> parseImport(builder)
            INCLUDE_KEY -> parseInclude(builder)
            LAYOUT_CLOSE_KEY -> parseLayoutClose(builder)
            LAYOUT_KEY -> parseLayout(builder)
            LAYOUT_SLOT_CLOSE_KEY -> parseSlotClose(builder)
            LAYOUT_SLOT_KEY -> parseSlot(builder)
            SET_CLOSE_KEY -> parsSetClose(builder)
            SET_KEY -> parsSet(builder)
            UNKNOWN -> parseUnknown(builder)
            else -> {
                parseExpression(builder)
                while (!builder.eof() && builder.tokenType == PIPE) {
                    parsePipe(builder)
                }
            }
        }
    }

    private fun parseEchoClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, ECHO_CLOSE_KEY, "Expected 'echo' keyword' ")
        closeOrError(builder, "syntax error: /echo expression")
        m.done(ParserElements.ECHO_CLOSE_ELEMENT)
    }

    private fun parseEcho(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, ECHO_KEY, "Expected 'echo' keyword' ")
        if (builder.tokenType == STRING) {
            parseString(builder)
        }
        if (builder.tokenType == PIPE) {
            parsePipe(builder)
        }
        closeOrError(builder, "syntax error: echo expression")
        m.done(ParserElements.ECHO_ELEMENT)
    }

    private fun parseUnknown(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, UNKNOWN, "Unexpected token", true)
        builder.error("Unexpected token")
        m.done(ParserElements.UNKNOWN_ELEMENT)
    }

    private fun parseInclude(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, INCLUDE_KEY, "Expected 'include' keyword' ")
        parseExpression(builder)
        parseObject(builder, true)
        parsePipe(builder)
        closeOrError(builder, "syntax error: include 'path/to/file.js' | data | pipe")
        m.done(ParserElements.INCLUDE_ELEMENT)
    }

    private fun parseObject(builder: PsiBuilder, optional: Boolean = false) {
        if (!optional || builder.tokenType == BRACE) {
            val m = builder.mark()

            expect(builder, BRACE, "Expected brace", false) { it.trim() == "{" }
            if (builder.tokenType != BRACE && builder.tokenText?.trim() != "}") {
                parseObjectElement(builder)
                while (!builder.eof() && builder.tokenType == COMMA) {
                    builder.advanceLexer() // comma
                    parseObjectElement(builder)
                }
            }
            expect(builder, BRACE, "Expected brace", false) { it.trim() == "}" }

            m.done(ParserElements.OBJECT_ELEMENT)
        }
    }

    private fun parseObjectElement(builder: PsiBuilder) {
        parseObjectElementKey(builder)
        if (optional(builder, COLON, "Expected ':' ")) {
            parseExpression(builder)
        }
    }

    private fun parseObjectElementKey(builder: PsiBuilder) {
        val sym = optional(builder, SYMBOL, "Expected symbol")
        val num = optional(builder, NUMBER, "Expected symbol")

        val stg =
            if (builder.tokenType == STRING) {
                parseString(builder)
                true
            } else {
                false
            }

        if (!sym && !num && !stg) {
            builder.error("Expected symbol, number, or string")
        }
    }

    private fun parseArray(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, BRACKET, "Expected bracket", false) { it.trim() == "[" }

        if (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") {
            parseArray(builder)
        } else if (builder.tokenType != BRACKET && builder.tokenText?.trim() != "]") {
            parseExpression(builder)
        }
        while (!builder.eof() && builder.tokenType == COMMA) {
            builder.advanceLexer()
            parseExpression(builder)
        }

        expect(builder, BRACKET, "Expected bracket", false) { it.trim() == "]" }

        m.done(ParserElements.ARRAY_ELEMENT)
    }

    private fun parseSlotClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_CLOSE_KEY, "Expected slot keyword")
        m.done(LAYOUT_SLOT_CLOSE_ELEMENT)
    }

    private fun parseSlot(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_KEY, "Expected slot keyword")
        expect(builder, SYMBOL, "Expected identifier")
        parsePipe(builder)
        closeOrError(builder, "syntax error: slot symbol")
        m.done(LAYOUT_SLOT_ELEMENT)
    }

    private fun parseLayout(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_KEY, "Expected layout keyword")
        expect(builder, FILE, "Expected filepath")
        parsePipe(builder)
        if (builder.tokenType == BRACE) {
            parseObject(builder)
        }
        closeOrError(builder, "syntax error: layout 'path/to/file.js' | data | pipe")
        m.done(LAYOUT_ELEMENT)
    }

    private fun parseLayoutClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_CLOSE_KEY, "Expected /layout keyword")
        m.done(LAYOUT_CLOSE_ELEMENT)
    }

    private fun parsSetClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, SET_CLOSE_KEY, "Expected '/set' keyword")
        closeOrError(builder, "syntax error: /set ")
        m.done(SET_CLOSE_ELEMENT)
    }

    private fun parsSet(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, SET_KEY, "Expected 'set' keyword")
        expect(builder, SYMBOL, "Expected identifier")

        val hasEq = optional(builder, EQUAL, "Expected '=' keyword")
        val hasExp =
            if (builder.tokenType == FUNCTION_KEY || (builder.tokenType == PARENTHESIS && builder.rawLookup(1) == FUNCTION_KEY)) {
                val iife = optional(builder, PARENTHESIS, "Expected '('") { it.trim() == "(" }
                val hasFunction = parseFunction(builder)
                if (iife) {
                    expect(builder, PARENTHESIS, "Expected ')'") { it.trim() == ")" }
                    expect(builder, FUNCTION_ARGS, "Expected function arguments: (arg1[,arg2])")
                }
                hasFunction
            } else {
                parseExpression(builder, hasEq)
            }

        if (hasEq && !hasExp) builder.error("Expected expression after '='")
        if (!hasEq && hasExp) builder.error("Expected '='")

        parsePipe(builder)

        closeOrError(builder, "syntax error: set symbol | set symbol = expression")

        m.done(SET_ELEMENT)
    }

    private fun parseFunction(builder: PsiBuilder): Boolean {
        val m = builder.mark()

        expect(builder, FUNCTION_KEY, "Expected 'function' keyword")

        val hasFunction = expect(builder, FUNCTION_ARGS, "Expected function arguments: (arg1[,arg2])")
        expect(builder, BRACE, "Expected '{' ") { it.trim() == "{" }
        var braceCounter = 1
        while (
            braceCounter > 0 &&
            (
                !builder.eof() &&
                    (
                        builder.tokenType == BRACE ||
                            builder.tokenType == STATEMENT ||
                            builder.tokenType == SEMICOLON ||
                            builder.tokenType == UNKNOWN
                    )
            )
        ) {
            when (builder.tokenType) {
                UNKNOWN -> parseUnknown(builder)
                BRACE -> {
                    if (builder.tokenText?.trim() == "{") braceCounter++
                    if (builder.tokenText?.trim() == "}") braceCounter--
                    if (braceCounter != 0) builder.advanceLexer()
                }

                STATEMENT -> {
                    builder.advanceLexer()
                    optional(builder, SEMICOLON, "Expected ';' ", true)
                }

                else -> builder.advanceLexer()
            }
        }
        expect(builder, BRACE, "Expected '}' ") { it.trim() == "}" }

        m.done(ParserElements.FUNCTION_ELEMENT)
        return hasFunction
    }

    private fun parsePipe(builder: PsiBuilder) {
        if (builder.tokenType == PIPE) {
            expect(builder, PIPE, "Expected pipe (|>)")
            parseExpression(builder)
        }
    }

    private fun parseImport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, IMPORT_KEY, "Expected 'import' keyword")
        expect(builder, IMPORT_VALUES, "Expected import values", true)
        expect(builder, IMPORT_FROM, "Expected 'from' keyword")
        expect(builder, FILE, "Expected path string")

        closeOrError(builder, "syntax error: import {a,b} from 'path/to/file.js'")

        m.done(ParserElements.IMPORT_ELEMENT)
    }

    private fun parseExport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_KEY, "Expected 'export' keyword")
        if (optional(builder, FUNCTION_KEY, "Expected 'function' keyword")) {
            expect(builder, SYMBOL, "Expected function name")
            expect(builder, FUNCTION_ARGS, "Expected function name")
            m.done(ParserElements.EXPORT_FUNCTION_ELEMENT)
        } else {
            expect(builder, SYMBOL, "Expected symbol", true)

            val hasEq = optional(builder, EQUAL, "Expected '=' keyword")
            var hasExpression = false
            if (hasEq) hasExpression = parseExpression(builder)
            if (hasEq && !hasExpression) builder.error("Expected expression after '='")

            while (!builder.eof() && builder.tokenType == PIPE) {
                val hasPipe = optional(builder, PIPE, "Expected pipe (|>)")
                var hasPipeExpression = false
                if (hasPipe) hasPipeExpression = parseExpression(builder)
                if (hasPipe && !hasPipeExpression) builder.error("Expected expression after '|>'")
            }

            closeOrError(builder, "syntax error: export symbol | export symbol = expression")

            if (hasEq) {
                m.done(ParserElements.EXPORT_ELEMENT)
            } else {
                m.done(ParserElements.EXPORT_OPEN_ELEMENT)
            }
        }
    }

    private fun closeOrError(builder: PsiBuilder, errorMsg: String) {
        while (builder.tokenType != VBLOCK_CLOSE && !builder.eof()) {
            if (builder.tokenType == UNKNOWN) {
                parseUnknown(builder)
            } else {
                builder.error(errorMsg)
                builder.advanceLexer()
            }
        }
    }

    private fun parseExpression(builder: PsiBuilder, required: Boolean = true): Boolean {
        val m = builder.mark()

        var hasExpression = false
        while (
            !builder.eof() &&
            (
                (builder.tokenType == BRACE && builder.tokenText?.trim() == "{") ||
                    (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") ||
                    builder.tokenType == BOOLEAN ||
                    builder.tokenType == COLON ||
                    builder.tokenType == COMMA ||
                    builder.tokenType == DOT ||
                    builder.tokenType == INSTANCEOF ||
                    builder.tokenType == MINUS ||
                    builder.tokenType == NUMBER ||
                    builder.tokenType == PARENTHESIS ||
                    builder.tokenType == PLUS ||
                    builder.tokenType == PLUS ||
                    builder.tokenType == REGEX ||
                    builder.tokenType == STRING ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == UNKNOWN ||
                    builder.tokenType == NEW
            )
        ) {
            if (builder.tokenType == BRACE) {
                parseObject(builder)
                hasExpression = true
            } else if (builder.tokenType == STRING) {
                parseString(builder)
                hasExpression = true
            } else if (builder.tokenType == BRACKET) {
                parseArray(builder)
                hasExpression = true
            } else if (
                builder.tokenType == REGEX
            ) {
                parseRegex(builder)
                hasExpression = true
            } else if (
                builder.tokenType == BOOLEAN ||
                builder.tokenType == COLON ||
                builder.tokenType == COMMA ||
                builder.tokenType == DOT ||
                builder.tokenType == INSTANCEOF ||
                builder.tokenType == MINUS ||
                builder.tokenType == NEW ||
                builder.tokenType == NUMBER ||
                builder.tokenType == PARENTHESIS ||
                builder.tokenType == PLUS ||
                builder.tokenType == PLUS ||
                builder.tokenType == SYMBOL
            ) {
                builder.advanceLexer()
                hasExpression = true
            } else if (builder.tokenType == UNKNOWN) {
                parseUnknown(builder)
                hasExpression = false
            } else {
                val m = builder.mark()
                hasExpression = false
                builder.error("Unexpected token")
                builder.advanceLexer()
                m.done(ParserElements.UNKNOWN_ELEMENT)
            }
        }
        if (!hasExpression && required) builder.error("Expected expression")
        if (hasExpression) m.done(ParserElements.EXPRESSION_ELEMENT) else m.drop()

        return hasExpression
    }

    private fun parseRegex(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, REGEX, "Expected REGEX", true)
        m.done(ParserElements.REGEX_ELEMENT)
    }

    private fun parseString(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, STRING, "Expected string", true)
        m.done(ParserElements.STRING_ELEMENT)
    }

    private fun parseExportClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_CLOSE_KEY, "Expected '/export' keyword")

        m.done(ParserElements.EXPORT_CLOSE_ELEMENT)
    }

    private fun parseFor(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, FOR_KEY, "Expected 'for' keyword")
        // PARSE VALUE
        var value = false
        while (
            !builder.eof() &&
            (
                builder.tokenType == BRACE ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == COMMA ||
                    builder.tokenType == BRACKET ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            value = true
            builder.advanceLexer()
            if (builder.tokenType == UNKNOWN) {
                value = false
                builder.error("Unexpected for content")
            }
            if (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") {
                parseArray(builder)
            }
        }

        if (!value) builder.error("Expected value")

        expect(builder, FOR_OF, "Expected 'of' keyword")

        // PARSE COLLECTION
        var collection = false
        while (
            !builder.eof() &&
            (
                (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") ||
                    (builder.tokenType == BRACE && builder.tokenText?.trim() == "{") ||
                    builder.tokenType == STRING ||
                    builder.tokenType == NUMBER ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == COMMA ||
                    builder.tokenType == PARENTHESIS ||
                    builder.tokenType == DOT ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            collection = true
            if (builder.tokenType == BRACKET) {
                parseArray(builder)
            }

            if (builder.tokenType == BRACE) {
                parseObject(builder)
            }

            if (builder.tokenType == STRING) {
                parseString(builder)
            }

            if (builder.tokenType == SYMBOL ||
                builder.tokenType == PARENTHESIS ||
                builder.tokenType == DOT ||
                builder.tokenType == COMMA ||
                builder.tokenType == NUMBER
            ) {
                builder.advanceLexer()
            }
            if (builder.tokenType == UNKNOWN) {
                collection = false
                parseUnknown(builder)
            }
        }
        if (!collection) builder.error("Expected collection")
        parsePipe(builder)
        closeOrError(builder, "syntax error: for [value] in [collection]")

        m.done(ParserElements.FOR_ELEMENT)
    }

    private fun parseForClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, FOR_CLOSE_KEY, "Expected '/for' keyword")
        closeOrError(builder, "syntax error: for [value] in [collection]")

        m.done(ParserElements.FOR_CLOSE_ELEMENT)
    }

    private fun parseJavaScript(builder: PsiBuilder) {
        val marker = builder.mark()

        expect(builder, JSBLOCK_OPEN, "Expected javascript element")
        expect(builder, JAVASCRIPT, "Expected javascript element", true)
        expect(builder, JSBLOCK_CLOSE, "Expected javascript element")

        marker.done(JAVASCRIPT_ELEMENT)
    }

    private fun parseCommentBlock(builder: PsiBuilder) {
        val marker = builder.mark()

        // Consume opening token
        builder.advanceLexer()

        // Consume content tokens
        while (!builder.eof() &&
            builder.tokenType == LexerTokens.COMMENT_CONTENT
        ) {
            builder.advanceLexer()
        }

        // Consume closing token if present
        if (builder.tokenType == LexerTokens.COMMENT_END) {
            builder.advanceLexer()
        }

        marker.done(ParserElements.COMMENT_BLOCK)
    }
}
