/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.lexer.LexerTokens.ASYNC_KEY
import org.js.vento.plugin.lexer.LexerTokens.COMMENT_START
import org.js.vento.plugin.lexer.LexerTokens.ECHO_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.ECHO_KEY
import org.js.vento.plugin.lexer.LexerTokens.ELSEIF_KEY
import org.js.vento.plugin.lexer.LexerTokens.ELSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_KEY
import org.js.vento.plugin.lexer.LexerTokens.FRONTMATTER_OPEN
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_KEY
import org.js.vento.plugin.lexer.LexerTokens.IF_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.IF_KEY
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_KEY
import org.js.vento.plugin.lexer.LexerTokens.JSBLOCK_OPEN
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_KEY
import org.js.vento.plugin.lexer.LexerTokens.PIPE
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.SET_KEY
import org.js.vento.plugin.lexer.LexerTokens.UNKNOWN
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_CLOSE
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_OPEN
import org.js.vento.plugin.parser.ParserElements.VENTO_BLOCK

/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses the root structure of a Vento template file and constructs the AST.
 * - Delegates parsing of specific elements, such as JavaScript blocks, to dedicated methods.
 *
 * Workflow:
 * 1. The `parse` method processes the entire file content.
 * 2. The parsing is done incrementally, processing each token in the file.
 * 3. Elements like JavaScript blocks or generic template elements are handled by corresponding methods.
 *
 * Key methods:
 * - `parse`: The entry point for parsing, iterates through the token stream and processes each token.
 * - `parseElement`: Handles parsing of individual elements in the structure.
 * - `parseJavaScriptElement`: Responsible for parsing blocks of JavaScript code embedded in the template.
 *
 * See also:
 * - `PsiParser` for IntelliJ IDEA's parsing handler interfaces.
 * - `VentoParserDefinition` for how this parser integrates with the IDE.
 * - `VentoJavaScriptInjector` for handling JavaScript code injection in parsed elements.
 */
class Parser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType
        builder.setDebugMode(true)

        when (tokenType) {
            FRONTMATTER_OPEN -> {
                parseFrontmatter(builder)
            }

            COMMENT_START -> {
                parseCommentBlock(builder)
            }

            JSBLOCK_OPEN -> {
                parseJavaScript(builder)
            }

            VBLOCK_OPEN -> {
                val m = builder.mark()
                expect(builder, VBLOCK_OPEN, "Expected '{{' ")
                parseVentoElemenet(builder)
                expect(builder, VBLOCK_CLOSE, "Expected '}}' ")
                m.done(VENTO_BLOCK)
            }

            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.HTML_CONTENT)
            }
        }
    }

    fun parseVentoElemenet(builder: PsiBuilder) {
        when (builder.tokenType) {
            ASYNC_KEY -> {
                parseFunctionSignature(builder)
            }

            ECHO_CLOSE_KEY -> {
                parseEchoClose(builder)
            }

            ECHO_KEY -> {
                parseEcho(builder)
            }

            ELSEIF_KEY -> {
                parseElseIf(builder)
            }

            ELSE_KEY -> {
                parseElse(builder)
            }

            EXPORT_CLOSE_KEY -> {
                parseExportClose(builder)
            }

            EXPORT_KEY -> {
                parseExport(builder)
            }

            FOR_CLOSE_KEY -> {
                parseForClose(builder)
            }

            FOR_KEY -> {
                parseFor(builder)
            }

            FUNCTION_CLOSE_KEY -> {
                parseFunctionClose(builder)
            }

            FUNCTION_KEY -> {
                parseFunctionSignature(builder, true)
            }

            IF_CLOSE_KEY -> {
                parseIfClose(builder)
            }

            IF_KEY -> {
                parseIf(builder)
            }

            IMPORT_KEY -> {
                parseImport(builder)
            }

            INCLUDE_KEY -> {
                parseInclude(builder)
            }

            LAYOUT_CLOSE_KEY -> {
                parseLayoutClose(builder)
            }

            LAYOUT_KEY -> {
                parseLayout(builder)
            }

            LAYOUT_SLOT_CLOSE_KEY -> {
                parseSlotClose(builder)
            }

            LAYOUT_SLOT_KEY -> {
                parseSlot(builder)
            }

            SET_CLOSE_KEY -> {
                parsSetClose(builder)
            }

            SET_KEY -> {
                parsSet(builder)
            }

            UNKNOWN -> {
                parseUnknown(builder)
            }

            else -> {
                parseJavaScriptExpression(builder)
                while (!builder.eof() && builder.tokenType == PIPE) {
                    parsePipe(builder)
                }
            }
        }
    }
}
