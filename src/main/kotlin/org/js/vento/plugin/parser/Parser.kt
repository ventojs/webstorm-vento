/*
 * Copyright (c) 2025 Florian Hehlen & Ã“scar Otero
 * All rights reserved.
 */

package org.js.vento.plugin.parser

import com.intellij.lang.ASTNode
import com.intellij.lang.PsiBuilder
import com.intellij.lang.PsiParser
import com.intellij.psi.tree.IElementType
import org.js.vento.plugin.VentoLanguage
import org.js.vento.plugin.lexer.LexerTokens
import org.js.vento.plugin.lexer.LexerTokens.BRACE
import org.js.vento.plugin.lexer.LexerTokens.BRACKET
import org.js.vento.plugin.lexer.LexerTokens.COMMA
import org.js.vento.plugin.lexer.LexerTokens.DOT
import org.js.vento.plugin.lexer.LexerTokens.EQUAL
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_FUNCTION_END
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_FUNCTION_START
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.EXPORT_VAR
import org.js.vento.plugin.lexer.LexerTokens.FILE
import org.js.vento.plugin.lexer.LexerTokens.FOR_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_KEY
import org.js.vento.plugin.lexer.LexerTokens.FOR_OF
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_ARGS
import org.js.vento.plugin.lexer.LexerTokens.FUNCTION_KEY
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_FROM
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_KEY
import org.js.vento.plugin.lexer.LexerTokens.IMPORT_VALUES
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_END
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_KEY
import org.js.vento.plugin.lexer.LexerTokens.INCLUDE_START
import org.js.vento.plugin.lexer.LexerTokens.JAVASCRIPT_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_CLOSE_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_END
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_KEY
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_SLOT_START
import org.js.vento.plugin.lexer.LexerTokens.LAYOUT_START
import org.js.vento.plugin.lexer.LexerTokens.NUMBER
import org.js.vento.plugin.lexer.LexerTokens.OBJECT
import org.js.vento.plugin.lexer.LexerTokens.PARENTHESIS
import org.js.vento.plugin.lexer.LexerTokens.PIPE
import org.js.vento.plugin.lexer.LexerTokens.REGEX
import org.js.vento.plugin.lexer.LexerTokens.SET_CLOSE_KEY
import org.js.vento.plugin.lexer.LexerTokens.SET_KEY
import org.js.vento.plugin.lexer.LexerTokens.STRING
import org.js.vento.plugin.lexer.LexerTokens.SYMBOL
import org.js.vento.plugin.lexer.LexerTokens.UNKNOWN
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_CLOSE
import org.js.vento.plugin.lexer.LexerTokens.VBLOCK_OPEN
import org.js.vento.plugin.parser.ParserElements.EXPORT_FUNCTION_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.LAYOUT_SLOT_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_CLOSE_ELEMENT
import org.js.vento.plugin.parser.ParserElements.SET_ELEMENT
import org.js.vento.plugin.parser.ParserElements.VENTO_ELEMENT

/**
 * A parser implementation for Vento template files.
 *
 * This class is responsible for converting a sequence of tokens generated by
 * the VentoLexer into a structured Abstract Syntax Tree (AST) representation
 * by defining parsing rules for various elements in the Vento language.
 *
 * Primary functionality:
 * - Parses the root structure of a Vento template file and constructs the AST.
 * - Delegates parsing of specific elements, such as JavaScript blocks, to dedicated methods.
 *
 * Workflow:
 * 1. The `parse` method processes the entire file content.
 * 2. The parsing is done incrementally, processing each token in the file.
 * 3. Elements like JavaScript blocks or generic template elements are handled by corresponding methods.
 *
 * Key methods:
 * - `parse`: The entry point for parsing, iterates through the token stream and processes each token.
 * - `parseElement`: Handles parsing of individual elements in the structure.
 * - `parseJavaScriptElement`: Responsible for parsing blocks of JavaScript code embedded in the template.
 *
 * See also:
 * - `PsiParser` for IntelliJ IDEA's parsing handler interfaces.
 * - `VentoParserDefinition` for how this parser integrates with the IDE.
 * - `VentoJavaScriptInjector` for handling JavaScript code injection in parsed elements.
 */
class VentoParser : PsiParser {
    override fun parse(root: IElementType, builder: PsiBuilder): ASTNode {
        val rootMarker = builder.mark()

        while (!builder.eof()) {
            parseElement(builder)
        }

        rootMarker.done(root)
        return builder.treeBuilt
    }

    fun parseElement(builder: PsiBuilder) {
        val tokenType = builder.tokenType
        builder.setDebugMode(true)

        when (tokenType) {
            VBLOCK_OPEN -> {
                val m = builder.mark()
                expect(builder, VBLOCK_OPEN, "Expected '{{' ")
                parseVentoElemenet(builder)
                expect(builder, VBLOCK_CLOSE, "Expected '}}' ")
                m.done(VENTO_ELEMENT)
            }

            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.DEFAULT_ELEMENT)
            }
        }
    }

    private fun parseVentoElemenet(builder: PsiBuilder) {
        when (builder.tokenType) {
//            COMMENT_START, TRIM_COMMENT_START -> parseCommentBlock(builder)
//            JAVASCRIPT_START -> parseJavaScript(builder)
//            VARIABLE_START -> parseVariable(builder)
            FOR_KEY -> parseFor(builder)
            FOR_CLOSE_KEY -> parseForClose(builder)
            IMPORT_KEY -> parseImport(builder)
            EXPORT_KEY -> parseExport(builder)
            EXPORT_CLOSE_KEY -> parseExportClose(builder)
//            EXPORT_FUNCTION_START -> parseExportFunction(builder)
//            LAYOUT_START -> parseLayout(builder)
//            LAYOUT_CLOSE_START -> parseLayoutClose(builder)
            SET_KEY -> parsSet(builder)
            SET_CLOSE_KEY -> parsSetClose(builder)
//            STRING, REGEX, BRACKET, DOT, IDENTIFIER, EXPRESSION, UNKNOWN -> parseExpression(builder)
            STRING -> parseString(builder)
//            LAYOUT_SLOT_START -> parseSlot(builder)
//            LAYOUT_SLOT_CLOSE_START -> parseSlotClose(builder)
//            OBJECT -> parseObject(builder)
            INCLUDE_START -> parseInclude(builder)
            UNKNOWN -> parseUnknown(builder)
            else -> {
                val marker = builder.mark()
                builder.advanceLexer()
                marker.done(ParserElements.DEFAULT_ELEMENT)
            }
        }
    }

    private fun parseUnknown(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, UNKNOWN, "Unexpected token", true)
        builder.error("Unexpected token")
        m.done(ParserElements.UNKNOWN_ELEMENT)
    }

    private fun parseInclude(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, INCLUDE_START, "Expected '{{' ")
        expect(builder, INCLUDE_KEY, "Expected 'include' keyword' ")
        parseExpression(builder)
        parseObject(builder)
        parsePipe(builder)
        expect(builder, INCLUDE_END, "Expected '}}'")
        m.done(ParserElements.INCLUDE_ELEMENT)
    }

    private fun parseObject(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, BRACE, "Expected bracket", false) { it.trim() == "{" }
        if (builder.tokenType != BRACE && builder.tokenText?.trim() != "}") {
            parseObjectElement(builder)
            while (!builder.eof() && builder.tokenType == COMMA) {
                builder.advanceLexer() // comma
                parseObjectElement(builder)
            }
        }
        expect(builder, BRACE, "Expected bracket", false) { it.trim() == "}" }

        m.done(ParserElements.OBJECT_ELEMENT)
    }

    private fun parseObjectElement(builder: PsiBuilder) {
        parseObjectElementKey(builder)
        if (optional(builder, LexerTokens.COLON, "Expected ':' ")) {
            parseExpression(builder)
        }
    }

    private fun parseObjectElementKey(builder: PsiBuilder) {
        val sym = optional(builder, SYMBOL, "Expected symbol")
        val num = optional(builder, NUMBER, "Expected symbol")

        val stg =
            if (builder.tokenType == STRING) {
                parseString(builder)
                true
            } else {
                false
            }

        if (!sym && !num && !stg) {
            builder.error("Expected symbol, number, or string")
        }
    }

    private fun parseArray(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, BRACKET, "Expected bracket", false) { it.trim() == "[" }
        if (builder.tokenType != BRACKET && builder.tokenText?.trim() != "]") {
            parseExpression(builder)
            while (!builder.eof() && builder.tokenType == COMMA) {
                builder.advanceLexer()
                parseExpression(builder)
            }
        }
        expect(builder, BRACKET, "Expected bracket", false) { it.trim() == "]" }

        m.done(ParserElements.ARRAY_ELEMENT)
    }

    private fun parseSlotClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_CLOSE_START, "Expected '{{' ")
        expect(builder, LAYOUT_SLOT_CLOSE_KEY, "Expected slot keyword")
        expect(builder, LAYOUT_SLOT_CLOSE_END, "Expected '}}'")
        m.done(LAYOUT_SLOT_CLOSE_ELEMENT)
    }

    private fun parseSlot(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_SLOT_START, "Expected '{{' ")
        expect(builder, LAYOUT_SLOT_KEY, "Expected slot keyword")
        expect(builder, SYMBOL, "Expected identifier")
        parsePipe(builder)
        expect(builder, LAYOUT_SLOT_END, "Expected '}}'")
        m.done(LAYOUT_SLOT_ELEMENT)
    }

    private fun parseLayout(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_START, "Expected '{{' ")
        expect(builder, LAYOUT_KEY, "Expected layout keyword")
        expect(builder, FILE, "Expected filepath")
        parsePipe(builder)
        if (builder.tokenType == OBJECT) {
            parseObject(builder)
        }
        expect(builder, LAYOUT_END, "Expected '}}'")
        m.done(LAYOUT_ELEMENT)
    }

    private fun parseLayoutClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, LAYOUT_CLOSE_START, "Expected '{{' ")
        expect(builder, LAYOUT_CLOSE_KEY, "Expected /layout keyword")
        expect(builder, LAYOUT_CLOSE_END, "Expected '}}'")
        m.done(LAYOUT_CLOSE_ELEMENT)
    }

    private fun parsSetClose(builder: PsiBuilder) {
        val m = builder.mark()
        expect(builder, SET_CLOSE_KEY, "Expected '/set' keyword")
        closeOrError(builder, "syntax error: /set ")
        m.done(SET_CLOSE_ELEMENT)
    }

    private fun parsSet(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, SET_KEY, "Expected 'set' keyword")
        expect(builder, SYMBOL, "Expected identifier")

        val hasEq = optional(builder, EQUAL, "Expected '=' keyword")

        val hasExp: Boolean = parseExpression(builder, hasEq)

        if (hasEq && !hasExp) builder.error("Expected expression after '='")
        if (!hasEq && hasExp) builder.error("Expected '='")

        parsePipe(builder)

        closeOrError(builder, "syntax error: set symbol | set symbol = expression")

        m.done(SET_ELEMENT)
    }

    private fun parsePipe(builder: PsiBuilder) {
        if (builder.tokenType == PIPE) {
            expect(builder, PIPE, "Expected pipe (|>)")
            parseExpression(builder)
        }
    }

    private fun parseImport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, IMPORT_KEY, "Expected 'import' keyword")
        expect(builder, IMPORT_VALUES, "Expected import values", true)
        expect(builder, IMPORT_FROM, "Expected 'from' keyword")
        expect(builder, FILE, "Expected path string")

        closeOrError(builder, "syntax error: import {a,b} from 'path/to/file.js'")

        m.done(ParserElements.IMPORT_ELEMENT)
    }

    private fun parseExport(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_KEY, "Expected 'export' keyword")
        if (optional(builder, FUNCTION_KEY, "Expected 'function' keyword")) {
            expect(builder, SYMBOL, "Expected function name")
            expect(builder, FUNCTION_ARGS, "Expected function name")
            m.done(ParserElements.EXPORT_ELEMENT)
        } else {
            expect(builder, SYMBOL, "Expected symbol", true)

            val hasEq = optional(builder, EQUAL, "Expected '=' keyword")
            var hasExpression = false
            if (hasEq) hasExpression = parseExpression(builder)
            if (hasEq && !hasExpression) builder.error("Expected expression after '='")

            while (!builder.eof() && builder.tokenType == PIPE) {
                val hasPipe = optional(builder, PIPE, "Expected pipe (|>)")
                var hasPipeExpression = false
                if (hasPipe) hasPipeExpression = parseExpression(builder)
                if (hasPipe && !hasPipeExpression) builder.error("Expected expression after '|>'")
            }

            closeOrError(builder, "syntax error: export symbol | export symbol = expression")

            if (hasEq) {
                m.done(ParserElements.EXPORT_ELEMENT)
            } else {
                m.done(ParserElements.EXPORT_OPEN_ELEMENT)
            }
        }
    }

    private fun closeOrError(builder: PsiBuilder, errorMsg: String) {
        while (builder.tokenType != VBLOCK_CLOSE) {
            if (builder.tokenType == UNKNOWN) {
                parseUnknown(builder)
            } else {
                builder.error(errorMsg)
                builder.advanceLexer()
            }
        }
    }

    private fun parseExpression(builder: PsiBuilder, required: Boolean = true): Boolean {
        val m = builder.mark()

        var hasExpression = false
        while (
            !builder.eof() &&
            (
                builder.tokenType == NUMBER ||
                    builder.tokenType == REGEX ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == STRING ||
                    (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") ||
                    (builder.tokenType == BRACE && builder.tokenText?.trim() == "{") ||
                    builder.tokenType == DOT ||
                    builder.tokenType == PARENTHESIS ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            if (builder.tokenType == BRACE) {
                parseObject(builder)
                hasExpression = true
            } else if (builder.tokenType == STRING) {
                parseString(builder)
                hasExpression = true
            } else if (builder.tokenType == BRACKET) {
                parseArray(builder)
                hasExpression = true
            } else if (
                builder.tokenType == SYMBOL ||
                builder.tokenType == NUMBER ||
                builder.tokenType == DOT ||
                builder.tokenType == PARENTHESIS ||
                builder.tokenType == REGEX
            ) {
                builder.advanceLexer()
                hasExpression = true
            } else if (builder.tokenType == UNKNOWN) {
                parseUnknown(builder)
                hasExpression = false
            }
        }
        if (!hasExpression && required) builder.error("Expected expression")
        if (hasExpression) m.done(ParserElements.EXPRESSION_ELEMENT) else m.drop()

        return hasExpression
    }

    private fun parseString(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, STRING, "Expected string", true)

        m.done(ParserElements.STRING_ELEMENT)
    }

    private fun parseExportClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, LexerTokens.EXPORT_CLOSE_KEY, "Expected '/export' keyword")

        m.done(ParserElements.EXPORT_CLOSE_ELEMENT)
    }

    private fun parseExportFunction(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, EXPORT_FUNCTION_START, "Expected '{{' ")
        expect(builder, EXPORT_KEY, "Expected 'export' keyword")
        expect(builder, FUNCTION_KEY, "Expected 'function' keyword")
        expect(builder, EXPORT_VAR, "Expected function name")
        expect(builder, FUNCTION_ARGS, "Expected function arguments: (arg1[,arg2])", true)
        expect(builder, EXPORT_FUNCTION_END, "Expected '}}' ")

        m.done(EXPORT_FUNCTION_ELEMENT)
    }

    private fun parseFor(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, FOR_KEY, "Expected 'for' keyword")
        var value = false
        while (
            !builder.eof() &&
            (
                builder.tokenType == BRACE ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == COMMA ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            value = true
            builder.advanceLexer()
            if (builder.tokenType == UNKNOWN) {
                value = false
                builder.error("Unexpected for content")
            }
        }
        if (!value) builder.error("Expected value")
        expect(builder, FOR_OF, "Expected 'of' keyword")
        var collection = false
        while (
            !builder.eof() &&
            (
                (builder.tokenType == BRACKET && builder.tokenText?.trim() == "[") ||
                    (builder.tokenType == BRACE && builder.tokenText?.trim() == "{") ||
                    builder.tokenType == STRING ||
                    builder.tokenType == SYMBOL ||
                    builder.tokenType == COMMA ||
                    builder.tokenType == PARENTHESIS ||
                    builder.tokenType == DOT ||
                    builder.tokenType == UNKNOWN
            )
        ) {
            collection = true
            if (builder.tokenType == BRACKET) {
                parseArray(builder)
            }

            if (builder.tokenType == BRACE) {
                parseObject(builder)
            }

            if (builder.tokenType == STRING) {
                parseString(builder)
            }

            if (builder.tokenType == SYMBOL || builder.tokenType == PARENTHESIS || builder.tokenType == DOT) {
                builder.advanceLexer()
            }
            if (builder.tokenType == UNKNOWN) {
                collection = false
                parseUnknown(builder)
            }
        }
        if (!collection) builder.error("Expected collection")
        parsePipe(builder)
        closeOrError(builder, "syntax error: for [value] in [collection]")

        m.done(ParserElements.FOR_ELEMENT)
    }

    private fun parseForClose(builder: PsiBuilder) {
        val m = builder.mark()

        expect(builder, FOR_CLOSE_KEY, "Expected '/for' keyword")
        closeOrError(builder, "syntax error: for [value] in [collection]")

        m.done(ParserElements.FOR_ELEMENT)
    }

    private fun parseVariable(builder: PsiBuilder) {
        val m = builder.mark()
        builder.advanceLexer() // consume {{ or {{-

        // Consume content tokens until we see the end or EOF
        while (
            !builder.eof() &&
            (
                builder.tokenType == LexerTokens.VARIABLE_ELEMENT ||
                    builder.tokenType == PIPE ||
                    builder.tokenType == STRING ||

                    builder.tokenType == UNKNOWN
            )
        ) {
            if (builder.tokenType == UNKNOWN) {
                parseUnknown(builder)
            }
            builder.advanceLexer()
        }

        // Expect end
        if (builder.tokenType == LexerTokens.VARIABLE_END) {
            builder.advanceLexer()
        } else {
            builder.error("Unexpected variable content")
        }

        m.done(ParserElements.JAVACRIPT_VARIABLE_ELEMENT)
    }

    private fun parseJavaScript(builder: PsiBuilder) {
        val marker = builder.mark()

        if (builder.tokenType == JAVASCRIPT_START) {
            builder.advanceLexer()
        }

        if (builder.tokenType == ParserElements.JAVASCRIPT_ELEMENT) {
            builder.advanceLexer()
        }

        if (builder.tokenType == LexerTokens.JAVASCRIPT_END) {
            builder.advanceLexer()
        }

        marker.done(ParserElements.JAVASCRIPT_ELEMENT)
    }

    private fun parseCommentBlock(builder: PsiBuilder) {
        val marker = builder.mark()

        // Consume opening token
        builder.advanceLexer()

        // Consume content tokens
        while (!builder.eof() &&
            builder.tokenType == LexerTokens.COMMENT_CONTENT
        ) {
            builder.advanceLexer()
        }

        // Consume closing token if present
        if (builder.tokenType == LexerTokens.COMMENT_END ||
            builder.tokenType == LexerTokens.TRIM_COMMENT_END
        ) {
            builder.advanceLexer()
        }

        marker.done(ParserElements.COMMENT_BLOCK)
    }
}

/**
 * Represents an element type for the Vento language.
 * Typically used for syntax/AST nodes in the PSI tree.
 */
class ParserElement(debugName: String) : IElementType(debugName, VentoLanguage)

private fun expect(
    builder: PsiBuilder,
    expected: IElementType,
    message: String,
    expectMultipleTokens: Boolean = false,
    test: (text: String) -> Boolean = { true },
): Boolean {
    return if (builder.tokenType == expected) {
        builder.tokenText?.let {
            if (!test(it)) builder.error("Unexpected token. found: '$it' ; expected: '$expected'")
        }
        builder.advanceLexer()

        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
        }
        builder.error(message)
        false
    }
}

private fun optional(builder: PsiBuilder, expected: IElementType, message: String, expectMultipleTokens: Boolean = false): Boolean {
    return if (builder.tokenType == expected) {
        builder.advanceLexer()
        return if (expectMultipleTokens && builder.tokenType == expected) {
            expect(builder, expected, message, true)
        } else {
            true
        }
    } else {
        if (builder.tokenType == UNKNOWN) {
            builder.advanceLexer()
            builder.error(message)
            return false
        }
        false
    }
}
